<script>
const NAME_KEY = "va_player_name";
const ALIGN_KEY = "va_alignment";

// Oath trial progress keys
const OATH_IDX = "va_oath_idx";     // 0..10 (question index)
const OATH_GOOD = "va_oath_good";
const OATH_EVIL = "va_oath_evil";
const OATH_DONE = "va_oath_done";   // "1" when finished

const dlg = document.getElementById("dlg");
const dlgName = document.getElementById("dlgName");
const dlgText = document.getElementById("dlgText");
const dlgBtns = document.getElementById("dlgBtns");

function showDialogue({ name, text, buttons = [] }) {
  dlgName.textContent = name || "";
  dlgText.innerHTML = "";
  dlgBtns.innerHTML = "";
  dlg.classList.remove("hidden");

  if (typeof text === "string") {
    dlgText.textContent = text;
  } else {
    dlgText.appendChild(text);
  }

  buttons.forEach(b => {
    const btn = document.createElement("button");
    btn.className = "dlgBtn";
    btn.textContent = b.label;
    btn.onclick = b.onClick;
    dlgBtns.appendChild(btn);
  });
}

function hideDialogue() {
  dlg.classList.add("hidden");
}

async function loadJSON(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error("Failed to load " + url);
  return await res.json();
}

function getInt(key, fallback = 0) {
  const v = parseInt(localStorage.getItem(key) || "", 10);
  return Number.isFinite(v) ? v : fallback;
}

function saveProgress({ idx, good, evil }) {
  localStorage.setItem("va_save_active", "1");
  localStorage.setItem("va_episode", "volume1_ep1");
  localStorage.setItem("va_screen", "oath_trial");

  localStorage.setItem(OATH_IDX, String(idx));
  localStorage.setItem(OATH_GOOD, String(good));
  localStorage.setItem(OATH_EVIL, String(evil));
}

function clearTrialProgressOnly() {
  localStorage.removeItem(OATH_IDX);
  localStorage.removeItem(OATH_GOOD);
  localStorage.removeItem(OATH_EVIL);
  localStorage.removeItem(OATH_DONE);
}

async function askName(promptData) {
  return new Promise(resolve => {
    const input = document.createElement("input");
    input.className = "nameInput";
    input.placeholder = "Your name";
    input.maxLength = 18;

    showDialogue({
      name: promptData.speaker || "The Voice",
      text: promptData.text || "Speak your name.",
      buttons: [{
        label: "Continue",
        onClick: () => {
          const nm = (input.value || "").trim() || "Traveler";
          localStorage.setItem(NAME_KEY, nm);
          hideDialogue();
          resolve(nm);
        }
      }]
    });

    dlgText.appendChild(input);
    setTimeout(() => input.focus(), 50);
  });
}

async function askGoodEvil(q) {
  return new Promise(resolve => {
    showDialogue({
      name: q.speaker || "The Voice",
      text: q.text,
      buttons: [
        { label: q.good.label, onClick: () => { hideDialogue(); resolve("good"); } },
        { label: q.evil.label, onClick: () => { hideDialogue(); resolve("evil"); } }
      ]
    });
  });
}

async function runEpisode1() {
  // Load the catalog
  const data = await loadJSON("/data/episodes/volume1_ep1/oath_trial.json");

  // If already finished, just show the result again (or move on later)
  if (localStorage.getItem(OATH_DONE) === "1") {
    const name = localStorage.getItem(NAME_KEY) || "Traveler";
    const align = localStorage.getItem(ALIGN_KEY) || "myriador";
    const result = align === "dreadheim" ? data.results.dreadheim : data.results.myriador;

    showDialogue({
      name: result.speaker,
      text: result.text.replace("{name}", name),
      buttons: [{
        label: result.button,
        onClick: () => {
          hideDialogue();
          alert("Next area: " + result.toScreen);
        }
      }]
    });
    return;
  }

  // Ask name if not set
  if (!localStorage.getItem(NAME_KEY)) {
    await askName(data.namePrompt);
  }

  // Resume progress
  let idx = getInt(OATH_IDX, 0);
  let good = getInt(OATH_GOOD, 0);
  let evil = getInt(OATH_EVIL, 0);

  // Save initial resume state (so it becomes resumable immediately)
  saveProgress({ idx, good, evil });

  // Ask remaining questions from idx
  while (idx < data.questions.length) {
    const q = data.questions[idx];

    const choice = await askGoodEvil(q);
    if (choice === "good") good += 1;
    else evil += 1;

    idx += 1;
    saveProgress({ idx, good, evil });
  }

  // Tiebreaker if needed
  if (good === evil) {
    const tieChoice = await askGoodEvil(data.tiebreaker);
    if (tieChoice === "good") good += 1;
    else evil += 1;

    // Save after tiebreaker too
    saveProgress({ idx, good, evil });
  }

  // Decide alignment
  const name = localStorage.getItem(NAME_KEY) || "Traveler";
  const isDreadheim = evil > good;

  localStorage.setItem(ALIGN_KEY, isDreadheim ? "dreadheim" : "myriador");
  localStorage.setItem(OATH_DONE, "1");

  const result = isDreadheim ? data.results.dreadheim : data.results.myriador;

  showDialogue({
    name: result.speaker,
    text: result.text.replace("{name}", name),
    buttons: [
      {
        label: result.button,
        onClick: () => {
          hideDialogue();
          alert("Next area: " + result.toScreen);
        }
      }
    ]
  });
}

runEpisode1();
</script>

