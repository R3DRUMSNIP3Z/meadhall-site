<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Dreadheim — Forest Entrance</title>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
    }

    /* ===== Inventory & Badge Styles ===== */
    .va-qty, .inv-qty, .item-qty, .va-stack, .stack {
      position: absolute !important;
      right: 6px !important;
      bottom: 6px !important;
      z-index: 999 !important;
      min-width: 18px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #7a1d1d;
      color: #fff;
      font: 12px/1 ui-sans-serif, system-ui;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,.35);
    }

    .va-item, .inv-cell { position: relative; isolation: isolate; }
    .va-name, .inv-name {
      position: absolute; left: 6px; right: 6px; bottom: 6px;
      z-index: 2; pointer-events: none; overflow: visible;
    }

    #vaBagBadge:empty, .bag-badge:empty, .inventory-badge:empty {
      display: none !important;
    }
  </style>
</head>

<body>
  <canvas id="map"></canvas>

  <script>
    (function () {
      try { localStorage.setItem("va_bag_unread", "0"); } catch (e) {}

      function nukeBadge() {
        const sel = "#vaBagBadge, .bag-badge, .inventory-badge";
        document.querySelectorAll(sel).forEach(el => {
          el.textContent = "";
          el.style.display = "none";
          el.removeAttribute("data-count");
        });
      }

      nukeBadge();
      window.addEventListener("pageshow", nukeBadge);
      window.addEventListener("focus", nukeBadge);
      document.addEventListener("visibilitychange", () => { if (!document.hidden) nukeBadge(); });
    })();
  </script>

  <script type="module">
    // --- Dreadheim Forest Entrance (Overworld with slow-chasing boar + loot + bat flock) ---
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");

    // ====== CONFIG ======
    const ASSETS = {
      bg: "/guildbook/maps/dreadheimforest.png",
      hero: window.getHeroSprite
        ? window.getHeroSprite()
        : "/guildbook/avatars/dreadheim-warrior.png",
      boar: "/guildbook/avatars/enemies/diseasedboar.png",
      meat: "/guildbook/loot/infectedboarmeat.png",
      bat1: "/guildbook/avatars/enemies/dreadheimbat.png",
      bat2: "/guildbook/avatars/enemies/dreadheimbat2.png",
      bat3: "/guildbook/avatars/enemies/dreadheimbat3.png"
    };

    // --- Edge exits ---
    const LEFT_EXIT_URL = "/game.html";
    const RIGHT_EXIT_URL = "/dreadheimperimeters.html";
    const EXIT_MARGIN = 4;
    const BATTLE_URL = "/dreadheimbattle.html";

    // --- Fade + warp (shared) ---
    function fadeTo(seconds = 0.25, after) {
      const f = document.createElement("div");
      Object.assign(f.style, {
        position: "fixed",
        inset: "0",
        background: "black",
        opacity: "0",
        transition: `opacity ${seconds}s ease`,
        zIndex: "999999"
      });
      document.body.appendChild(f);
      requestAnimationFrame(() => (f.style.opacity = "1"));
      setTimeout(() => after && after(), seconds * 1000);
    }

    let transitioning = false;
    function warpTo(url) {
      if (transitioning) return;
      transitioning = true;
      fadeTo(0.25, () => (window.location.href = url));
    }
    function goToBattle() { warpTo(BATTLE_URL); }

    // ====== WORLD CONSTS ======
    const WALKWAY_TOP_RATIO = 0.86;
    const SPEED = 4;
    const GRAVITY = 0.8;
    const JUMP_VELOCITY = -16;
    const HERO_W = 96, HERO_H = 96;
    const BOAR_W = 110, BOAR_H = 90;

    const ENGAGE_DIST = 120;
    const ALERT_DIST = 320;
    const CHASE_SPEED = 1.2;
    const PATROL_SPEED = 1.8;

    // ====== DPR / Resize ======
    function fitCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = window.innerWidth, h = window.innerHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    fitCanvas();
    window.addEventListener("resize", fitCanvas);

    // ====== LOAD IMAGES ======
    function load(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => res(img);
        img.onerror = () => rej(new Error("Missing asset: " + src));
        img.src = src;
      });
    }

    let bg, heroImg, boarImg, meatImg;
    let batFrames = [];

    // ====== WORLD / ENTITIES ======
    let groundY = Math.round(window.innerHeight * WALKWAY_TOP_RATIO);
    const hero = {
      x: Math.max(0, Math.min(window.innerWidth - HERO_W, window.innerWidth / 2 - HERO_W / 2)),
      y: groundY - HERO_H,
      w: HERO_W, h: HERO_H, vx: 0, vy: 0, onGround: true
    };

    const BOAR_DEAD = () => localStorage.getItem("va_bf_boar_defeated") === "1";
    const LOOT_TAKEN = () => localStorage.getItem("va_loot_infectedboarmeat") === "1";

    const boar = {
      x: Math.min(window.innerWidth - BOAR_W - 160, hero.x + 240),
      y: groundY - BOAR_H,
      w: BOAR_W, h: BOAR_H,
      vx: PATROL_SPEED,
      dir: -1,
      minX: 80,
      maxX: Math.max(380, window.innerWidth - 260),
      alive: !BOAR_DEAD()
    };

    const loot = {
      x: Math.min(window.innerWidth - 120, Math.max(120, hero.x + 200)),
      y: groundY - 48, w: 42, h: 42,
      visible: BOAR_DEAD() && !LOOT_TAKEN()
    };

    // ====== BAT FLOCK — free-roaming wanderers (30×30) ======
/** @typedef {{
  x:number,y:number,w:number,h:number,
  vx:number,vy:number,
  dir:1|-1,frame:number,lastFrame:number,frameDelay:number,
  maxSpeed:number, wanderTheta:number, wanderJitter:number, wanderRadius:number,
}} Bat */

const bats = /** @type {Bat[]} */([]);
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

function spawnBat(opts = {}) {
  const W = window.innerWidth, H = window.innerHeight;
  const size = 30; // fixed per your request
  // Random position anywhere on screen with a margin
  const margin = 40;
  const x = opts.x ?? rand(margin, W - margin);
  const y = opts.y ?? rand(margin, H - margin);

  // Random initial velocity in any direction
  const angle = rand(0, Math.PI * 2);
  const speed = opts.speed ?? rand(0.7, 1.6);
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;

  const b = {
    x, y, w: size, h: size,
    vx, vy,
    dir: vx >= 0 ? 1 : -1,
    frame: 0,
    lastFrame: 0,
    frameDelay: randi(90, 140),
    maxSpeed: 2.0,                  // cap velocity
    wanderTheta: rand(0, Math.PI*2),
    wanderJitter: 0.12,             // how quickly heading drifts
    wanderRadius: 0.28              // how strongly wander pulls
  };
  bats.push(b);
}

function spawnFlock(n = 7) {
  for (let i = 0; i < n; i++) spawnBat();
}


    // Recalc ground & patrol when viewport changes
    function refreshBounds() {
      groundY = Math.round(window.innerHeight * WALKWAY_TOP_RATIO);
      hero.y = Math.min(hero.y, groundY - hero.h);
      if (hero.y >= groundY - hero.h) { hero.y = groundY - hero.h; hero.vy = 0; hero.onGround = true; }
      boar.y = groundY - boar.h;
      boar.minX = 80;
      boar.maxX = Math.max(boar.minX + 300, window.innerWidth - 260);
      loot.y = groundY - 48;

      // keep bats within their canopy band after resize
      const now = performance.now();
      for (const b of bats) {
        const baseY = Math.round(window.innerHeight * b.hoverY);
        const bob = Math.sin(now / b.hoverSpeed) * b.hoverAmp;
        b.y = baseY + bob;
      }
    }
    window.addEventListener("resize", refreshBounds);

    // ====== INPUT ======
    const keys = new Set();
    window.addEventListener("keydown", e => {
      keys.add(e.key);
      if ((e.key === " " || e.key === "w" || e.key === "W" || e.key === "ArrowUp") && hero.onGround) {
        hero.vy = JUMP_VELOCITY;
        hero.onGround = false;
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", e => keys.delete(e.key));

    // ===== DEV RESET =====
    window.addEventListener("keydown", e => {
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === "r") {
        localStorage.removeItem("va_bf_boar_defeated");
        localStorage.removeItem("va_loot_infectedboarmeat");
        boar.alive = true;
        loot.visible = false;
        toast("Dev Reset: Boar restored and loot cleared.");
      }
    });

    // ===== CLICK EVENTS =====
    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (boar.alive &&
        mx >= boar.x - 10 && mx <= boar.x + boar.w + 10 &&
        my >= boar.y - 10 && my <= boar.y + boar.h + 10) {
        goToBattle();
        return;
      }
      if (loot.visible &&
        mx >= loot.x && mx <= loot.x + loot.w &&
        my >= loot.y && my <= loot.y + loot.h) {
        window.Inventory?.add?.("infectedboarmeat", "Infected Boar Meat", ASSETS.meat, 1);
        localStorage.setItem("va_loot_infectedboarmeat", "1");
        loot.visible = false;
        toast("You pick up: Infected Boar Meat");
      }
    });

    // ===== TOAST =====
    function toast(msg) {
      const t = document.createElement("div");
      t.textContent = msg;
      Object.assign(t.style, {
        position: "fixed", left: "50%", top: "16px",
        transform: "translateX(-50%)",
        background: "rgba(20,20,20,.92)", color: "#e6d5a9",
        border: "1px solid #9b834d",
        padding: "10px 14px",
        borderRadius: "10px",
        zIndex: "999999",
        boxShadow: "0 6px 24px rgba(0,0,0,.45)",
        fontFamily: "Cinzel, serif"
      });
      document.body.appendChild(t);
      setTimeout(() => t.remove(), 2000);
    }

    // ====== UPDATE ======
    function step() {
      // hero move
      let vx = 0;
      if (keys.has("ArrowLeft") || keys.has("a") || keys.has("A")) vx -= SPEED;
      if (keys.has("ArrowRight") || keys.has("d") || keys.has("D")) vx += SPEED;
      hero.vx = vx;

      if (hero.x <= EXIT_MARGIN) return warpTo(LEFT_EXIT_URL);
      if (hero.x + hero.w >= window.innerWidth - EXIT_MARGIN) return warpTo(RIGHT_EXIT_URL);

      hero.x = Math.min(Math.max(hero.x + hero.vx, 0), window.innerWidth - hero.w);
      hero.vy += GRAVITY;
      hero.y += hero.vy;
      const floor = groundY - hero.h;
      if (hero.y >= floor) { hero.y = floor; hero.vy = 0; hero.onGround = true; }

      if (BOAR_DEAD() && boar.alive) { boar.alive = false; loot.visible = !LOOT_TAKEN(); }

      if (boar.alive) {
        const dx = (hero.x + hero.w/2) - (boar.x + boar.w/2);
        const dist = Math.abs(dx);
        if (dist <= ENGAGE_DIST) goToBattle();
        else if (dist <= ALERT_DIST) {
          boar.dir = dx > 0 ? 1 : -1;
          boar.x += CHASE_SPEED * boar.dir;
        } else {
          boar.x += PATROL_SPEED * boar.dir;
          if (boar.x <= boar.minX) { boar.x = boar.minX; boar.dir = 1; }
          if (boar.x >= boar.maxX) { boar.x = boar.maxX; boar.dir = -1; }
        }
      }

      // --- Bats animation + motion ---
      const now = performance.now();
      for (let i = bats.length - 1; i >= 0; i--) {
        const b = bats[i];
        if (batFrames.length === 3 && now - b.lastFrame > b.frameDelay) {
          b.frame = (b.frame + 1) % 3;
          b.lastFrame = now;
        }
        const baseY = Math.round(window.innerHeight * b.hoverY);
        const bob = Math.sin(now / b.hoverSpeed) * b.hoverAmp;
        b.y = baseY + bob;

        b.x += b.vx * b.dir;
        if (b.dir > 0 && b.x > window.innerWidth + 60) {
          bats.splice(i, 1);
          spawnBat({ x: rand(-220, -80), yPct: b.hoverY, speed: b.vx, dir: 1 });
        } else if (b.dir < 0 && b.x < -60) {
          bats.splice(i, 1);
          spawnBat({ x: rand(window.innerWidth + 80, window.innerWidth + 220), yPct: b.hoverY, speed: b.vx, dir: -1 });
        }
      }
    }

    // ====== RENDER ======
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (bg) ctx.drawImage(bg, 0, 0, window.innerWidth, window.innerHeight);

      // bats (flip when flying left)
      if (batFrames.length === 3) {
        for (const b of bats) {
          const img = batFrames[b.frame];
          ctx.save();
          if (b.dir < 0) {
            ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
            ctx.scale(-1, 1);
            ctx.drawImage(img, -b.w / 2, -b.h / 2, b.w, b.h);
          } else {
            ctx.drawImage(img, b.x, b.y, b.w, b.h);
          }
          ctx.restore();
        }
      }

      if (heroImg) ctx.drawImage(heroImg, hero.x, hero.y, hero.w, hero.h);
      if (boar.alive && boarImg) {
        ctx.save();
        if (boar.dir < 0) {
          ctx.translate(boar.x + boar.w/2, boar.y + boar.h/2);
          ctx.scale(-1,1);
          ctx.drawImage(boarImg, -boar.w/2, -boar.h/2, boar.w, boar.h);
        } else ctx.drawImage(boarImg, boar.x, boar.y, boar.w, boar.h);
        ctx.restore();
      }

      if (loot.visible && meatImg)
        ctx.drawImage(meatImg, loot.x, loot.y, loot.w, loot.h);
    }

    function loop() { step(); render(); requestAnimationFrame(loop); }

    // ====== BOOT ======
    Promise.all([
      load(ASSETS.bg), load(ASSETS.hero), load(ASSETS.boar), load(ASSETS.meat),
      load(ASSETS.bat1), load(ASSETS.bat2), load(ASSETS.bat3)
    ])
      .then(([b, h, bo, m, b1, b2, b3]) => {
        bg = b; heroImg = h; boarImg = bo; meatImg = m;
        batFrames = [b1, b2, b3];
        spawnFlock(5);               // << spawn 5 small bats (30×30)
        refreshBounds();
        loop();
      })
      .catch(() => { refreshBounds(); loop(); });
  </script>
</body>
</html>






